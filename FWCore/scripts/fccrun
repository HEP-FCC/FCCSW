#!/usr/bin/env python2

import os
import sys
import argparse


# these default properties are filtered as otherwise they will clutter the argument list
__filterGaudiProps = [ "ContextService", "Cardinality", "Context", "CounterList", "EfficiencyRowFormat",
  "Enable", "ErrorCount", "ErrorMax", "ErrorsPrint", "ExtraInputs", "ExtraOutputs",
  "FilterCircularDependencies", "StatEntityList", "IsIOBound", "MonitorService", "NeededResources",
  "PropertiesPrint", "RegisterForContextService", "RegularRowFormat", "RequireObjects", "RootInTES",
  "StatPrint", "StatTableHeader", "Timeline", "TypePrint", "UseEfficiencyRowFormat",
  "VetoObjects","OutputLevel",
  "EnableFaultHandler" ,"InhibitPathes" ,"EnableAccessHandler" ,"ForceLeaves" ,"RootName"
  ,"DataAccessName", "DataFaultName", "RootCLID"
  ]

#---------------------------------------------------------------------
if __name__ == "__main__":
    # ensure that we (and the subprocesses) use the C standard localization
    if os.environ.get('LC_ALL') != 'C':
        os.environ['LC_ALL'] = 'C'

    # run all the configuration files
    # we generate arguments from them, so we need to load them 
    # before parsing the arguments
    # to avoid parsing them twice, just assume the positional arguments
    # come first and as soon as we encounter "-" we stop
    for f in sys.argv[1:]:
      if f[0] != '-':
        execfile(f)
      else:
        break

    parser = argparse.ArgumentParser(description="Run job in the FCC framework")
    parser.add_argument("config_files", nargs="+",
                      help="Gaudi config (python) files describing the job")
    parser.add_argument("--dry-run", action="store_true",
                      help="Do not actually run the job, just parse the config files")
    parser.add_argument("-v", "--verbose", action="store_true",
                      help="Run job with verbose output")
    parser.add_argument("-n", "--num-events", type=int,
                      help="Number of events to run")
    parser.add_argument("-l", "--list", action="store_true",
                      help="Print all the configurable components available in the framework")
    parser.add_argument("--gdb", action="store_true", help="Attach gdb debugger")

    # TODO: Don't want to advertise this until tested.
    # GaudiPython Parallel Mode Option
    #   Argument must be an integer in range [ -1, sys_cpus ]
    #   -1   : All available cpus
    #    0   : Serial Mode (traditional gaudirun)
    #    n>0 : parallel with n cpus (n <= sys_cpus)
    parser.add_argument("--ncpus",  type=int, default=0,
                      help="Start Gaudi in parallel mode using NCPUS processes. "
                           "0 => serial mode (default), -1 => use all CPUs")



    # print a doc line showing the configured algorithms
    for alg in ApplicationMgr().TopAlg:
      print ' --> ', alg.name(), 
    print "",'\n'

    option_db = {}

    # loop over all components that were configured in the options file
    for conf in ApplicationMgr.allConfigurables.values():
      # skip public tools and the applicationmgr itself
      if "ToolSvc" not in conf.name() and "ApplicationMgr" not in conf.name():
        props = conf.getPropertiesWithDescription() #dict propertyname: (propertyvalue, propertydescription)
        for prop in props:
          # only add arguments for relevant properties
          if not prop in __filterGaudiProps:
            if not "Audit" in prop:
              # do not want to deal with other components / datahandles for now
                if not hasattr(props[prop][0], '__slots__'):
                  #print conf.name(), prop, props[prop]
                  try: # TODO: remove once duplicate elements sorted out
                    propvalue = props[prop][0]

                    # if it is set to "no value" it hasn't been touched in the options file

                    if propvalue == conf.propertyNoValue:
                       propvalue = conf.getDefaultProperty(prop) # thus get the default value
                    proptype = type(props[prop][0])
                    # if the property is a list of something, we need to set argparse nargs to '+'
                    propnargs = "?"
                    #print "proptype", proptype
                    if proptype == list:
                      # tricky edgecase: if the default is an empty list there is no way to get the type
                      if len(propvalue) == 0:
                        # just skip for now
                        print "Warning: cannot deduce type for property %s of %s. Needs to be set in options file." % (prop, conf.name())
                        continue
                      else:
                        # deduce type from first item of the list
                        proptype = type(propvalue[0])
                      propnargs = "+"
                      
                    parser.add_argument("--" + prop, type=proptype, help=props[prop][1],
                      nargs=propnargs,
                      default=propvalue)
                    # bookkeeping which option belongs to which configurable
                    option_db[prop] = conf
                  except argparse.ArgumentError:
                    pass




    #opts, unknown = parser.parse_known_args() #this is an 'internal' method
    # which returns 'parsed', the same as what parse_args() would return
    # and 'unknown', the remainder of that
    # the difference to parse_args() is that it does not exit when it finds redundant arguments



    #for arg in unknown:
    #    if arg.startswith(("-", "--")):
            #you can pass any arguments to add_argument

    opts=parser.parse_args()
    # turn namespace into dict
    opts_dict = vars(opts)
    for option in option_db:
      option_db[option].setProp(option, opts_dict[option])

    if opts.verbose:
      ApplicationMgr().OutputLevel = VERBOSE
    if opts.num_events is not None:
      ApplicationMgr().EvtMax = opts.num_events






    # Parallel Option ---------------------------------------------------------
    if opts.ncpus:
        from multiprocessing import cpu_count
        sys_cpus = cpu_count()
        if opts.ncpus > sys_cpus:
            s = "Invalid value : --ncpus : only %i cpus available" % sys_cpus
            parser.error(s)
        elif opts.ncpus < -1:
            s = "Invalid value : --ncpus must be integer >= -1"
            parser.error(s)

    # configure the logging
    import logging
    from GaudiKernel.ProcessJobOptions import (InstallRootLoggingHandler,
                                               PrintOff)

    prefix = "# "
    level = logging.INFO
    InstallRootLoggingHandler(prefix, level=level, with_time=opts.verbose)
    root_logger = logging.getLogger()





    from Gaudi.Main import gaudimain
    c = gaudimain()
    if not opts.dry_run:
        # Do the real processing
        retcode = c.run(opts.gdb, opts.ncpus)
        sys.exit(retcode)
